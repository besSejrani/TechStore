{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Introduction Goals Stripe Stripe Payment Stripe Subscription Cancel Subscription Authentication OAuth2 AWS Upload images on S3 Ecommerce Promotions Email Notification Print PDF commands Blog Rich text content markdown","title":"Introduction"},{"location":"#introduction","text":"","title":"Introduction"},{"location":"#goals","text":"","title":"Goals"},{"location":"#stripe","text":"Stripe Payment Stripe Subscription Cancel Subscription","title":"Stripe"},{"location":"#authentication","text":"OAuth2","title":"Authentication"},{"location":"#aws","text":"Upload images on S3","title":"AWS"},{"location":"#ecommerce","text":"Promotions Email Notification Print PDF commands","title":"Ecommerce"},{"location":"#blog","text":"Rich text content markdown","title":"Blog"},{"location":"0.installation/","text":"Installation Download Project Git git clone git@github.com:besSejrani/BlueberryShop.git Install Dependencies Client // NPM cd Client npm install // Yarn cd Client yarn install Server // NPM cd Server npm install // Yarn cd Server yarn install Run Application Script // NPM cd Server npm run dev // Yarn cd Server yarn run dev","title":"Installation"},{"location":"0.installation/#installation","text":"","title":"Installation"},{"location":"0.installation/#download-project","text":"Git git clone git@github.com:besSejrani/BlueberryShop.git","title":"Download Project"},{"location":"0.installation/#install-dependencies","text":"Client // NPM cd Client npm install // Yarn cd Client yarn install Server // NPM cd Server npm install // Yarn cd Server yarn install","title":"Install Dependencies"},{"location":"0.installation/#run-application","text":"Script // NPM cd Server npm run dev // Yarn cd Server yarn run dev","title":"Run Application"},{"location":"1.architecture/","text":"Architecture Model, View, Cotroller Personal Diagram Scaling Architecture Personal Diagram Microservices Personal Diagram CI/CD CI/CD URI Description Ansible Jenkins Provisioning Provisioner URI Description Terraform Monitoring Monitoring URI Description Grafana Prometheus Jaeger Service Bus Service Bus URI Description Kafka RabbitMQ API API URI Description REST GraphQL gRPC Containers Container URI Description Docker Kubernetes Istio Databases Database URI Description MySQL PostgreSQL MongoDB Redis Neo4j Elasticsearch Chaos Engineering Container URI Description Chaos Toolkit","title":"Architecture"},{"location":"1.architecture/#architecture","text":"","title":"Architecture"},{"location":"1.architecture/#model-view-cotroller","text":"Personal Diagram","title":"Model, View, Cotroller"},{"location":"1.architecture/#scaling-architecture","text":"Personal Diagram","title":"Scaling Architecture"},{"location":"1.architecture/#microservices","text":"Personal Diagram","title":"Microservices"},{"location":"1.architecture/#cicd","text":"CI/CD URI Description Ansible Jenkins","title":"CI/CD"},{"location":"1.architecture/#provisioning","text":"Provisioner URI Description Terraform","title":"Provisioning"},{"location":"1.architecture/#monitoring","text":"Monitoring URI Description Grafana Prometheus Jaeger","title":"Monitoring"},{"location":"1.architecture/#service-bus","text":"Service Bus URI Description Kafka RabbitMQ","title":"Service Bus"},{"location":"1.architecture/#api","text":"API URI Description REST GraphQL gRPC","title":"API"},{"location":"1.architecture/#containers","text":"Container URI Description Docker Kubernetes Istio","title":"Containers"},{"location":"1.architecture/#databases","text":"Database URI Description MySQL PostgreSQL MongoDB Redis Neo4j Elasticsearch","title":"Databases"},{"location":"1.architecture/#chaos-engineering","text":"Container URI Description Chaos Toolkit","title":"Chaos Engineering"},{"location":"2.uiux/","text":"UI & UX Sketching User Flow Sitemaps Sitemaps are hierarchical diagrams that show how pages are organized. Wireframes Figma Figma Plugins Plugin Kind Description Font Explorer Font Explore font variation Font Scale Font Define font variation Color Palettes Color Define a color palette Duotones Color Define a color palette Color Search Color Define a color by typing text Image Palette Color Define color palette from image A11y Color Color constrast checker Contrast Contrast Object constrast checker Able Accessibility Accessibility checker Design Lint Linter Design Linter Blush Image Image resources Design Inspo Image Image resources Humaans Image Image resources Illustrations Image Image resources Pexels Image Image resources Unsplash Image Image resources Remove BG Image Remove background image Feather Icons Icons Feather Icons resources Material Design Icons Icons Material Icons resources Iconify Icons Icons resources Streamline Icons Icons Icons resources Logo Creator Logo Logo resources Figchat Resource Chat Visualizer Figmotion Animation Animation Tool Vectary 3D 3D 3D Tool Autoflow Diagram Allows to create good looking diagrams Sitemap Diagram Create a sitemap from reel websites Chart Chart Allows to create good looking charts Wireframe Wireframe Allows to create good looking wireframes in 2-3 clicks Content Reel User Content Create user content","title":"UI & UX"},{"location":"2.uiux/#ui-ux","text":"","title":"UI &amp; UX"},{"location":"2.uiux/#sketching","text":"","title":"Sketching"},{"location":"2.uiux/#user-flow","text":"","title":"User Flow"},{"location":"2.uiux/#sitemaps","text":"Sitemaps are hierarchical diagrams that show how pages are organized.","title":"Sitemaps"},{"location":"2.uiux/#wireframes","text":"","title":"Wireframes"},{"location":"2.uiux/#figma","text":"","title":"Figma"},{"location":"2.uiux/#figma-plugins","text":"Plugin Kind Description Font Explorer Font Explore font variation Font Scale Font Define font variation Color Palettes Color Define a color palette Duotones Color Define a color palette Color Search Color Define a color by typing text Image Palette Color Define color palette from image A11y Color Color constrast checker Contrast Contrast Object constrast checker Able Accessibility Accessibility checker Design Lint Linter Design Linter Blush Image Image resources Design Inspo Image Image resources Humaans Image Image resources Illustrations Image Image resources Pexels Image Image resources Unsplash Image Image resources Remove BG Image Remove background image Feather Icons Icons Feather Icons resources Material Design Icons Icons Material Icons resources Iconify Icons Icons resources Streamline Icons Icons Icons resources Logo Creator Logo Logo resources Figchat Resource Chat Visualizer Figmotion Animation Animation Tool Vectary 3D 3D 3D Tool Autoflow Diagram Allows to create good looking diagrams Sitemap Diagram Create a sitemap from reel websites Chart Chart Allows to create good looking charts Wireframe Wireframe Allows to create good looking wireframes in 2-3 clicks Content Reel User Content Create user content","title":"Figma Plugins"},{"location":"3.client/","text":"Client React Framewok Client Side Rendering Client side rendering is faster at rendering after initial load, it comes with greate user experience, good variety of libraries and frameworks. Client side rendering doesn't shine with initial load time and SEO. For the moment, search engines like Bing, Yandex and more struggle to index web pages with a lot of Javascript, their ranking performs badly. Personal Diagram Server Side Rendering In contrast to client side rendering, Javascript is rendered as HTML, making it possible to be indexed in the first round trip by search engines and improve SEO. Initial load times are improved, allowing users to get content much faster in opposite with client side rendering. Decreasing load time, improves SEO and converts more clients. The process of server side rendering after initial load is higher than with client side rendering. Personal Diagram Choice For this project, Next.js was choosed over Gatsby and create-react-app for it's server-side rendering capabilities and for it's SEO support. Personal Diagram UI Library Material-UI Other Solution State Management Apollo Client Image: Inspired From Apollo Docs Basic Usage(recommended) Advanced Initializing state Cache Policies N/A Local state management Reactive variables + Cache Policies N/A State update cache.readQuery + cache.writeQuery cache.modify, cache.evict Pagination cache.radQuery + cache.writeQuery Cache Policies Apollo 3 Presentation, Khalil Stemmer Other Solution Configuration Environement Variables By creating an .env environment file, it's possible to add information and then retrieve it in the application at any time. It behaves like a central store, it's perfect for storing repeatable information like URLs. Warning All the information exposed in Next.js are not private, every one can see them. Do not store confidential information on Next via environement variables. .env NEXT_PUBLIC_DEVELOPMENT_SERVER=http://localhost:4000/graphql NEXT_PUBLIC_PRODUCTION_SERVER=https://blueberryshop.herokuapp.com/graphql GraphQL Code Generator Since all the backend is written in Typescript, it would be great to use those same types in the the frontend. That's exactly what GraphQL Code Generator does, it converts the backend API into Typescript. GraphQL Code Generator needs raw .graphql files to interact with the server. .graphql mutation AddProfilePicture($picture : Upload!) { addProfilePicture(picture : $picture) } GraphQL Code Generator needs a configuration file, named codegen.yaml, it explains to it, how to reach the server and how to retrieve the types. For the project, there are two files, one for development and one for production. GraphQL Code Generator Development overwrite : true schema : ${NEXT_PUBLIC_DEVELOPMENT_SERVER} documents : \"./Graphql/**/**/*.graphql\" # watch: true generates : Graphql/graphql-hooks.ts : plugins : - \"typescript\" - \"typescript-operations\" - \"typescript-react-apollo\" config : withHOC : false withComponent : false withHooks : true GraphQL Code Generator Production overwrite : true schema : ${NEXT_PUBLIC_PRODUCTION_SERVER} documents : \"./Graphql/**/**/*.graphql\" # watch: true generates : Graphql/graphql-hooks.ts : plugins : - \"typescript\" - \"typescript-operations\" - \"typescript-react-apollo\" config : withHOC : false withComponent : false withHooks : true In the package.json file on the client, there is a generate script to execute. The server must be running, otherwise the action will fail. script \"generate:dev\" : \"graphql-codegen -r dotenv/config --config ./codegen.yaml\" , \"generate:prod\" : \"graphql-codegen -r dotenv/config --config ./codegenProd.yaml\" , Libraries Library URI Description Typescript Link Typescript is a superset of Javascript, it allows to add types in development and detect compilation errors at compile time. Next.js Link Next.js is a server side rendering framework built on top of React, it optimizes search engine results. Material-UI Link Material-UI is a UI library component kit built on Google's material design system. React Hook Form Link React Hook Form is a light and performant library built on top of React hooks, it makes form validation very easy. Apollo Client Link Apollo Client is a GraphQL client library, it's simple API allows to use it as a local state management tool and to quickly write business code which mathers, in comparison of Redux's long boilerplate. GraphQL Code Generator Link GraphQL Code Generator allows to convert a GraphQL API into Typescript. Apollo-Upload-Client Link Sources Source Author URI Apollo Server and Client Auth Example Next.js Example Link Apollo Client State Management Example Apollo Example Link Strongly Typed Next.js Michael Stromer Link Typescript, Next GraphQL Youtube Playlist Ben Awad Link Demo Ecommerce Vercel Link Github Demo Ecommerce Vercel Link","title":"Client"},{"location":"3.client/#client","text":"","title":"Client"},{"location":"3.client/#react-framewok","text":"","title":"React Framewok"},{"location":"3.client/#client-side-rendering","text":"Client side rendering is faster at rendering after initial load, it comes with greate user experience, good variety of libraries and frameworks. Client side rendering doesn't shine with initial load time and SEO. For the moment, search engines like Bing, Yandex and more struggle to index web pages with a lot of Javascript, their ranking performs badly. Personal Diagram","title":"Client Side Rendering"},{"location":"3.client/#server-side-rendering","text":"In contrast to client side rendering, Javascript is rendered as HTML, making it possible to be indexed in the first round trip by search engines and improve SEO. Initial load times are improved, allowing users to get content much faster in opposite with client side rendering. Decreasing load time, improves SEO and converts more clients. The process of server side rendering after initial load is higher than with client side rendering. Personal Diagram","title":"Server Side Rendering"},{"location":"3.client/#choice","text":"For this project, Next.js was choosed over Gatsby and create-react-app for it's server-side rendering capabilities and for it's SEO support. Personal Diagram","title":"Choice"},{"location":"3.client/#ui-library","text":"","title":"UI Library"},{"location":"3.client/#material-ui","text":"","title":"Material-UI"},{"location":"3.client/#other-solution","text":"","title":"Other Solution"},{"location":"3.client/#state-management","text":"","title":"State Management"},{"location":"3.client/#apollo-client","text":"Image: Inspired From Apollo Docs Basic Usage(recommended) Advanced Initializing state Cache Policies N/A Local state management Reactive variables + Cache Policies N/A State update cache.readQuery + cache.writeQuery cache.modify, cache.evict Pagination cache.radQuery + cache.writeQuery Cache Policies Apollo 3 Presentation, Khalil Stemmer","title":"Apollo Client"},{"location":"3.client/#other-solution_1","text":"","title":"Other Solution"},{"location":"3.client/#configuration","text":"","title":"Configuration"},{"location":"3.client/#environement-variables","text":"By creating an .env environment file, it's possible to add information and then retrieve it in the application at any time. It behaves like a central store, it's perfect for storing repeatable information like URLs. Warning All the information exposed in Next.js are not private, every one can see them. Do not store confidential information on Next via environement variables. .env NEXT_PUBLIC_DEVELOPMENT_SERVER=http://localhost:4000/graphql NEXT_PUBLIC_PRODUCTION_SERVER=https://blueberryshop.herokuapp.com/graphql","title":"Environement Variables"},{"location":"3.client/#graphql-code-generator","text":"Since all the backend is written in Typescript, it would be great to use those same types in the the frontend. That's exactly what GraphQL Code Generator does, it converts the backend API into Typescript. GraphQL Code Generator needs raw .graphql files to interact with the server. .graphql mutation AddProfilePicture($picture : Upload!) { addProfilePicture(picture : $picture) } GraphQL Code Generator needs a configuration file, named codegen.yaml, it explains to it, how to reach the server and how to retrieve the types. For the project, there are two files, one for development and one for production. GraphQL Code Generator Development overwrite : true schema : ${NEXT_PUBLIC_DEVELOPMENT_SERVER} documents : \"./Graphql/**/**/*.graphql\" # watch: true generates : Graphql/graphql-hooks.ts : plugins : - \"typescript\" - \"typescript-operations\" - \"typescript-react-apollo\" config : withHOC : false withComponent : false withHooks : true GraphQL Code Generator Production overwrite : true schema : ${NEXT_PUBLIC_PRODUCTION_SERVER} documents : \"./Graphql/**/**/*.graphql\" # watch: true generates : Graphql/graphql-hooks.ts : plugins : - \"typescript\" - \"typescript-operations\" - \"typescript-react-apollo\" config : withHOC : false withComponent : false withHooks : true In the package.json file on the client, there is a generate script to execute. The server must be running, otherwise the action will fail. script \"generate:dev\" : \"graphql-codegen -r dotenv/config --config ./codegen.yaml\" , \"generate:prod\" : \"graphql-codegen -r dotenv/config --config ./codegenProd.yaml\" ,","title":"GraphQL Code Generator"},{"location":"3.client/#libraries","text":"Library URI Description Typescript Link Typescript is a superset of Javascript, it allows to add types in development and detect compilation errors at compile time. Next.js Link Next.js is a server side rendering framework built on top of React, it optimizes search engine results. Material-UI Link Material-UI is a UI library component kit built on Google's material design system. React Hook Form Link React Hook Form is a light and performant library built on top of React hooks, it makes form validation very easy. Apollo Client Link Apollo Client is a GraphQL client library, it's simple API allows to use it as a local state management tool and to quickly write business code which mathers, in comparison of Redux's long boilerplate. GraphQL Code Generator Link GraphQL Code Generator allows to convert a GraphQL API into Typescript. Apollo-Upload-Client Link","title":"Libraries"},{"location":"3.client/#sources","text":"Source Author URI Apollo Server and Client Auth Example Next.js Example Link Apollo Client State Management Example Apollo Example Link Strongly Typed Next.js Michael Stromer Link Typescript, Next GraphQL Youtube Playlist Ben Awad Link Demo Ecommerce Vercel Link Github Demo Ecommerce Vercel Link","title":"Sources"},{"location":"4.server/","text":"Server Authentication Authentication is a broad topic, it can be achived in many ways, like session and cookies, session and in-memory database like Redis, and so on. At the end of the day, authentication is all about tradeofs, control or scalability. Session Authentication Using sessions for authentication gives great control over the service that the application provides to the end user. For obvious reasons, an administrator can create, ban, block or delete a user. Personal Diagram JWT Authentication Json Web Tokens are great for scalability, when using tokens, an extra round trip to the database is saved, improving performance and user experience. The down side of JWT tokens is that when the server emits a token, it has no more control over it. So, if a user violates a rule of conduct, the administrator can't block that user immediatly. A way to resolve this, is to add a Time To Live value to the token. Personal Diagram Choice Authorization OAuth2 Image: Inspired From Facebook Docs Payment AWS S3 Configuration Environment Variables Warning Environement Variables are sensible informations injected just before a server is starting. Don't forget to add the environment variable file to .gitignore , otherwise bots will scrape GitHub for sensible information and use your aws credentials, for example, for bitcoin mining. .env PORT= MONGO_ATLAS= JWT_SECRET= JWT_EXPIRES_IN= SENDGRID_API= REDIS_HOST= REDIS_PORT= REDIS_PASSWORD= REDIS_URL= GITHUB_CLIENT_ID= GITHUB_CLIENT_SECRET= GOOGLE_ID= GOOGLE_SECRET= TWITTER_API_KEY= TWITTER_API_SECRET_KEY= TWITTER_BEARER_TOKEN= AMAZON_S3_BUCKET= AMAZON_KEY_ID= AMAZON_SECRET_ACCESS_KEY= Environments Environment URI Description Node.js Link Node.js is a Javascript runtime environment, not a programming language. It'uses Chrome's open source Javascript engine, V8. By incorporating V8, it has access to the OS APIs. Libraries Library URI Description Typescript Link Typescript is a superset of Javascript, it allows to add types in development and detect compilation errors at compile time. Apollo-server-express Link Apollo-server-express, not to confuse with apollo-server, integrates very well with an existing Express server and adds GraphQL capabilties. TypeGraphQL Link TypeGraphQL allows to build a Typescript GraphQL API very easily, by just defining resolvers and using decorators, it automaticly creates a GraphQL schema DSL file. Typegoose Link Typegoose is a Typescript wrapper over mongoose for MongoDB. Instead of creating mongoose definitions and then create object interfaces for using Typescript, Typegoose handles this with decorators. Passport Link Passport is a authentication middleware for Node.js, it allows with the help of strategies to add OAuth capabilities to the application. Graphql-upload Link Sources Source Author URI GraphQL Official Link How to GraphQL Tutorial Link TypeGraphQL Youtube Playlist Ben Awad Link Upload Files Apollo docs Link","title":"Server"},{"location":"4.server/#server","text":"","title":"Server"},{"location":"4.server/#authentication","text":"Authentication is a broad topic, it can be achived in many ways, like session and cookies, session and in-memory database like Redis, and so on. At the end of the day, authentication is all about tradeofs, control or scalability.","title":"Authentication"},{"location":"4.server/#session-authentication","text":"Using sessions for authentication gives great control over the service that the application provides to the end user. For obvious reasons, an administrator can create, ban, block or delete a user. Personal Diagram","title":"Session Authentication"},{"location":"4.server/#jwt-authentication","text":"Json Web Tokens are great for scalability, when using tokens, an extra round trip to the database is saved, improving performance and user experience. The down side of JWT tokens is that when the server emits a token, it has no more control over it. So, if a user violates a rule of conduct, the administrator can't block that user immediatly. A way to resolve this, is to add a Time To Live value to the token. Personal Diagram","title":"JWT Authentication"},{"location":"4.server/#choice","text":"","title":"Choice"},{"location":"4.server/#authorization","text":"","title":"Authorization"},{"location":"4.server/#oauth2","text":"Image: Inspired From Facebook Docs","title":"OAuth2"},{"location":"4.server/#payment","text":"","title":"Payment"},{"location":"4.server/#aws-s3","text":"","title":"AWS S3"},{"location":"4.server/#configuration","text":"","title":"Configuration"},{"location":"4.server/#environment-variables","text":"Warning Environement Variables are sensible informations injected just before a server is starting. Don't forget to add the environment variable file to .gitignore , otherwise bots will scrape GitHub for sensible information and use your aws credentials, for example, for bitcoin mining. .env PORT= MONGO_ATLAS= JWT_SECRET= JWT_EXPIRES_IN= SENDGRID_API= REDIS_HOST= REDIS_PORT= REDIS_PASSWORD= REDIS_URL= GITHUB_CLIENT_ID= GITHUB_CLIENT_SECRET= GOOGLE_ID= GOOGLE_SECRET= TWITTER_API_KEY= TWITTER_API_SECRET_KEY= TWITTER_BEARER_TOKEN= AMAZON_S3_BUCKET= AMAZON_KEY_ID= AMAZON_SECRET_ACCESS_KEY=","title":"Environment Variables"},{"location":"4.server/#environments","text":"Environment URI Description Node.js Link Node.js is a Javascript runtime environment, not a programming language. It'uses Chrome's open source Javascript engine, V8. By incorporating V8, it has access to the OS APIs.","title":"Environments"},{"location":"4.server/#libraries","text":"Library URI Description Typescript Link Typescript is a superset of Javascript, it allows to add types in development and detect compilation errors at compile time. Apollo-server-express Link Apollo-server-express, not to confuse with apollo-server, integrates very well with an existing Express server and adds GraphQL capabilties. TypeGraphQL Link TypeGraphQL allows to build a Typescript GraphQL API very easily, by just defining resolvers and using decorators, it automaticly creates a GraphQL schema DSL file. Typegoose Link Typegoose is a Typescript wrapper over mongoose for MongoDB. Instead of creating mongoose definitions and then create object interfaces for using Typescript, Typegoose handles this with decorators. Passport Link Passport is a authentication middleware for Node.js, it allows with the help of strategies to add OAuth capabilities to the application. Graphql-upload Link","title":"Libraries"},{"location":"4.server/#sources","text":"Source Author URI GraphQL Official Link How to GraphQL Tutorial Link TypeGraphQL Youtube Playlist Ben Awad Link Upload Files Apollo docs Link","title":"Sources"},{"location":"5.database/","text":"Database MongoDB MongoDB Atlas Connection Typescript import \"dotenv/config\" ; import mongoose from \"mongoose\" ; export default async () => { try { await mongoose . connect ( process . env . MONGO_ATLAS ! , { useNewUrlParser : true , useCreateIndex : true , useUnifiedTopology : true , useFindAndModify : false , }); await console . log ( `Connected to database` ); } catch ( error ) { console . log ( error . message ); console . log ( `Couldn't connect to database` ); } }; Horizontal Scaling Schema Sources Source Kind URI MongoDB University Tutorial Link MongoDB Documentation Documentation Link","title":"Database"},{"location":"5.database/#database","text":"","title":"Database"},{"location":"5.database/#mongodb","text":"","title":"MongoDB"},{"location":"5.database/#mongodb-atlas-connection","text":"Typescript import \"dotenv/config\" ; import mongoose from \"mongoose\" ; export default async () => { try { await mongoose . connect ( process . env . MONGO_ATLAS ! , { useNewUrlParser : true , useCreateIndex : true , useUnifiedTopology : true , useFindAndModify : false , }); await console . log ( `Connected to database` ); } catch ( error ) { console . log ( error . message ); console . log ( `Couldn't connect to database` ); } };","title":"MongoDB Atlas Connection"},{"location":"5.database/#horizontal-scaling","text":"","title":"Horizontal Scaling"},{"location":"5.database/#schema","text":"","title":"Schema"},{"location":"5.database/#sources","text":"Source Kind URI MongoDB University Tutorial Link MongoDB Documentation Documentation Link","title":"Sources"},{"location":"6.testing/","text":"Testing Unit Tests Integration Tests End-To-End Testing Code coverage Testing Ratio Libraries Library URI Description Cypress Link Cypress is an End-To-End test runner written in Javascript, it is different from Selenium, another E2E suite tools, since it primarly focuses on E2E. Jest Link Jest is a testing library built by Facebook. It is a test runner providing data mocking, code coverage and snapshots. Jest is great for testing units tests and integration tests.","title":"Testing"},{"location":"6.testing/#testing","text":"","title":"Testing"},{"location":"6.testing/#unit-tests","text":"","title":"Unit Tests"},{"location":"6.testing/#integration-tests","text":"","title":"Integration Tests"},{"location":"6.testing/#end-to-end-testing","text":"","title":"End-To-End Testing"},{"location":"6.testing/#code-coverage","text":"","title":"Code coverage"},{"location":"6.testing/#testing-ratio","text":"","title":"Testing Ratio"},{"location":"6.testing/#libraries","text":"Library URI Description Cypress Link Cypress is an End-To-End test runner written in Javascript, it is different from Selenium, another E2E suite tools, since it primarly focuses on E2E. Jest Link Jest is a testing library built by Facebook. It is a test runner providing data mocking, code coverage and snapshots. Jest is great for testing units tests and integration tests.","title":"Libraries"},{"location":"7.security/","text":"Security Security Headers Helmet Helmet is a Node.js middleware which allows to set security headers. By default, it adds a Powered-By header, adds a XSS header and much more. Like mentionned on their website, it's not a silver bullet, but it can help. For the moment, the content security policy is set to false, since it blocks the GraphQL Playground, it is temporary. Typescript import helmet from \"helmet\" ; app . use ( helmet ({ contentSecurityPolicy : false })); Validation Frontend Input Validation Validating user inputs is very important since they can enter what ever they want and perform for example XSS, SQL injections and CSRF attacks. Modern frontend Javascript frameworks like React, Vue and Angular have already XSS validation in place. It doesn't mean that the frontend inputs are validated that the server shouldn't also validate incoming data. There is a lot of ways for sending data to the server without the need of a browser, like CURL, Postman API tool and many more. Typescript import React from \"react\" ; // React-Hook-Form import { ErrorMessage } from \"@hookform/error-message\" ; // Material-UI import { TextField , Typography } from \"@material-ui/core\" ; // =========================================================== type inputType = { type : string ; name : string ; id : string ; label : string ; multiline? : boolean ; rowsMax? : string ; inputRef : any ; value : string | number ; onChange : Function ; errors : any ; }; const inputForm : React.FC < inputType > = ({ type , name , id , label , multiline , rowsMax , inputRef , value , onChange , errors , }) => { return ( <> < TextField style = {{ margin : \"5px\" }} type = { type } name = { name } id = { id } label = { label } multiline = { multiline } rowsMax = { rowsMax } inputRef = { inputRef } value = { value } onChange = {( text ) => onChange ( text . target . value )} /> < ErrorMessage errors = { errors } name = { name } as = { < Typography variant = \"body2\" /> } > {({ messages }) => messages && Object . entries ( messages ). map (([ type , message ]) => ( < p key = { type } > { message } < /p> )) } < /ErrorMessage> < /> ); }; export default inputForm ; Server Input Validation Injection Express-mongo-sanitize Like SQL databases, injections can be performed by malicious users against a NoSQL database. Express-mongo-sanitize is a middleware, it will sanitize the incoming requests and replace the injections with ASCII characters. Typescript import mongoSanitize from \"express-mongo-sanitize\" ; app . use ( mongoSanitize ()); Hashing Hashing is a unique process of transforming data of variable length into fixed length. This process can also be composed of a secret and a salt in order to limit mass dictionary attacks. Algorithm Length MD5 128 bits, not recommended SHA-1 160 bits SHA-256 256 bits SHA-512 512 bits Bcrypt This hash function is very slow in order to dissuade malicious people from making mass attacks. Scrypt This hash function is very expensive in RAM, making the bulk attack very expensive. Bcryptjs Bcryptjs is a NPM package which allows to implement the Bcrypt algorithm, it's simple API is easy to use. Hash Data import bcrypt from \"bcryptjs\" const salt = await bcrypt . genSalt ( 12 ); const hash = await bcrypt . hash ( password , salt ); Compare Hash import bcrypt from \"bcryptjs\" ; const valid = await bcrypt . compare ( password , user . password ); Rate Limiting Rate limiting allows to limit the number of requests that a user can make on a specific endpoint / resource. Often, the register page is targeted and a brute force attack is performed for finding end user credentials. Limiting the number of requests that a user shouldn't exceed, limits the scope of attack and avoids unnecessary workload on server. The following code comes from one of Ben Awad's Gists Typescript // GraphQL import { MiddlewareFn } from \"type-graphql\" ; import { MyContext } from \"../Graphql/types/MyContext\" ; // In-Memory Database import { redis } from \"../Redis/index\" ; // ============================================================== const oneDay = 60 * 60 * 24 ; export const rateLimit : ( limit? : number ) => MiddlewareFn < MyContext > = ( limit = 50 ) => async ( { context : { req }, info }, next ) => { const key = `rate-limit: ${ info . fieldName } : ${ req . ip } ` ; const current = await redis . incr ( key ); if ( current > limit ) { throw new Error ( \"You are making too much requests\" ); } else if ( current === 1 ) { await redis . expire ( key , oneDay ); } return next (); }; Libraries Library URI Description helmet Link class-validator Link mongoose Link express-mongo-sanitize Link bcryptjs Link Sources Source Kind URI Rate Limiting Ben Awad Link","title":"Security"},{"location":"7.security/#security","text":"","title":"Security"},{"location":"7.security/#security-headers","text":"","title":"Security Headers"},{"location":"7.security/#helmet","text":"Helmet is a Node.js middleware which allows to set security headers. By default, it adds a Powered-By header, adds a XSS header and much more. Like mentionned on their website, it's not a silver bullet, but it can help. For the moment, the content security policy is set to false, since it blocks the GraphQL Playground, it is temporary. Typescript import helmet from \"helmet\" ; app . use ( helmet ({ contentSecurityPolicy : false }));","title":"Helmet"},{"location":"7.security/#validation","text":"","title":"Validation"},{"location":"7.security/#frontend-input-validation","text":"Validating user inputs is very important since they can enter what ever they want and perform for example XSS, SQL injections and CSRF attacks. Modern frontend Javascript frameworks like React, Vue and Angular have already XSS validation in place. It doesn't mean that the frontend inputs are validated that the server shouldn't also validate incoming data. There is a lot of ways for sending data to the server without the need of a browser, like CURL, Postman API tool and many more. Typescript import React from \"react\" ; // React-Hook-Form import { ErrorMessage } from \"@hookform/error-message\" ; // Material-UI import { TextField , Typography } from \"@material-ui/core\" ; // =========================================================== type inputType = { type : string ; name : string ; id : string ; label : string ; multiline? : boolean ; rowsMax? : string ; inputRef : any ; value : string | number ; onChange : Function ; errors : any ; }; const inputForm : React.FC < inputType > = ({ type , name , id , label , multiline , rowsMax , inputRef , value , onChange , errors , }) => { return ( <> < TextField style = {{ margin : \"5px\" }} type = { type } name = { name } id = { id } label = { label } multiline = { multiline } rowsMax = { rowsMax } inputRef = { inputRef } value = { value } onChange = {( text ) => onChange ( text . target . value )} /> < ErrorMessage errors = { errors } name = { name } as = { < Typography variant = \"body2\" /> } > {({ messages }) => messages && Object . entries ( messages ). map (([ type , message ]) => ( < p key = { type } > { message } < /p> )) } < /ErrorMessage> < /> ); }; export default inputForm ;","title":"Frontend Input Validation"},{"location":"7.security/#server-input-validation","text":"","title":"Server Input Validation"},{"location":"7.security/#injection","text":"","title":"Injection"},{"location":"7.security/#express-mongo-sanitize","text":"Like SQL databases, injections can be performed by malicious users against a NoSQL database. Express-mongo-sanitize is a middleware, it will sanitize the incoming requests and replace the injections with ASCII characters. Typescript import mongoSanitize from \"express-mongo-sanitize\" ; app . use ( mongoSanitize ());","title":"Express-mongo-sanitize"},{"location":"7.security/#hashing","text":"Hashing is a unique process of transforming data of variable length into fixed length. This process can also be composed of a secret and a salt in order to limit mass dictionary attacks. Algorithm Length MD5 128 bits, not recommended SHA-1 160 bits SHA-256 256 bits SHA-512 512 bits Bcrypt This hash function is very slow in order to dissuade malicious people from making mass attacks. Scrypt This hash function is very expensive in RAM, making the bulk attack very expensive.","title":"Hashing"},{"location":"7.security/#bcryptjs","text":"Bcryptjs is a NPM package which allows to implement the Bcrypt algorithm, it's simple API is easy to use. Hash Data import bcrypt from \"bcryptjs\" const salt = await bcrypt . genSalt ( 12 ); const hash = await bcrypt . hash ( password , salt ); Compare Hash import bcrypt from \"bcryptjs\" ; const valid = await bcrypt . compare ( password , user . password );","title":"Bcryptjs"},{"location":"7.security/#rate-limiting","text":"Rate limiting allows to limit the number of requests that a user can make on a specific endpoint / resource. Often, the register page is targeted and a brute force attack is performed for finding end user credentials. Limiting the number of requests that a user shouldn't exceed, limits the scope of attack and avoids unnecessary workload on server. The following code comes from one of Ben Awad's Gists Typescript // GraphQL import { MiddlewareFn } from \"type-graphql\" ; import { MyContext } from \"../Graphql/types/MyContext\" ; // In-Memory Database import { redis } from \"../Redis/index\" ; // ============================================================== const oneDay = 60 * 60 * 24 ; export const rateLimit : ( limit? : number ) => MiddlewareFn < MyContext > = ( limit = 50 ) => async ( { context : { req }, info }, next ) => { const key = `rate-limit: ${ info . fieldName } : ${ req . ip } ` ; const current = await redis . incr ( key ); if ( current > limit ) { throw new Error ( \"You are making too much requests\" ); } else if ( current === 1 ) { await redis . expire ( key , oneDay ); } return next (); };","title":"Rate Limiting"},{"location":"7.security/#libraries","text":"Library URI Description helmet Link class-validator Link mongoose Link express-mongo-sanitize Link bcryptjs Link","title":"Libraries"},{"location":"7.security/#sources","text":"Source Kind URI Rate Limiting Ben Awad Link","title":"Sources"},{"location":"8.performance/","text":"Performance Next.js Debouncing Logic What makes React great, is that it implements the concepts of the shadow DOM and the DOM well together. State in React is updated in the shadow Dom before updating the real DOM, in other words, rendering the DOM is costly, Input events and scroll events for example have tendancies to be fired after each change, to save performance, they should be minimized. By using the setTimeout function in the useEffect hook, events are updated only after 50 milliseconds. Between events, if they are still firing, the timer will reset and wait for another 50 milliseconds. The wait time is not cumulative. React useEffect useEffect (() => { const timer = setTimeout (() => { logic }, 50 ); return () => { clearTimeout ( timer ); }; }, [ state ]); Code Splitting By default, Next.js comes with code splitting. This means that the Javascript code on the login page will only be fetched, when and only the user navigates to the login page. Image Lazy Loading The same idea as code splitting refers to image lazy loading. Instead of fetching all the assets before the user needs them, Nextjs fetches with the help of the Image module, only images that are needed on the page. Note that the image lazy loading process can also be handled in plain Javascript with the help of the Intersection Observer API. An example can be found on one of my other projects 1 . Next.js import Image from \"next/image\" < Image width = { 300 } height = { 250 } className = { \"css class\" } onClick = {() => \"event\" } src = { \"imageUrl\" } title = { \"title\" } /> Vanilla Javascript const targets = document . querySelectorAll ( \"[data-lazy]\" ); const lazyLoad = ( target ) => { const io = new IntersectionObserver (( entries , observer ) => { entries . forEach (( entry ) => { if ( entry . isIntersecting ) { const img = entry . target ; const srcset = img . getAttribute ( \"data-lazy\" ); img . setAttribute ( \"srcset\" , srcset ); observer . disconnect (); } }); }); io . observe ( target ); }; targets . forEach ( lazyLoad ); WebP Support WebP is an efficient image coding format, it performs on average 30% better than JPEG or PNG for images size. The choice was clear, use only WebP. WebP as a 89% market share, but on some web browsers it's still new, like for example Firefox on Android, it supports WebP only since January 26. There is a way to show JPEG/PNG images to users who haven't yet updated their web browsers and WebP images to those who have updated their software, it will involve the Intersection Observer API, but this is a solution for another time. GraphQL Caching https://github.com/besSejrani/PWA-Camera/blob/master/src/js/utils/lazyImages.ts \u21a9","title":"Performance"},{"location":"8.performance/#performance","text":"","title":"Performance"},{"location":"8.performance/#nextjs","text":"","title":"Next.js"},{"location":"8.performance/#debouncing-logic","text":"What makes React great, is that it implements the concepts of the shadow DOM and the DOM well together. State in React is updated in the shadow Dom before updating the real DOM, in other words, rendering the DOM is costly, Input events and scroll events for example have tendancies to be fired after each change, to save performance, they should be minimized. By using the setTimeout function in the useEffect hook, events are updated only after 50 milliseconds. Between events, if they are still firing, the timer will reset and wait for another 50 milliseconds. The wait time is not cumulative. React useEffect useEffect (() => { const timer = setTimeout (() => { logic }, 50 ); return () => { clearTimeout ( timer ); }; }, [ state ]);","title":"Debouncing Logic"},{"location":"8.performance/#code-splitting","text":"By default, Next.js comes with code splitting. This means that the Javascript code on the login page will only be fetched, when and only the user navigates to the login page.","title":"Code Splitting"},{"location":"8.performance/#image-lazy-loading","text":"The same idea as code splitting refers to image lazy loading. Instead of fetching all the assets before the user needs them, Nextjs fetches with the help of the Image module, only images that are needed on the page. Note that the image lazy loading process can also be handled in plain Javascript with the help of the Intersection Observer API. An example can be found on one of my other projects 1 . Next.js import Image from \"next/image\" < Image width = { 300 } height = { 250 } className = { \"css class\" } onClick = {() => \"event\" } src = { \"imageUrl\" } title = { \"title\" } /> Vanilla Javascript const targets = document . querySelectorAll ( \"[data-lazy]\" ); const lazyLoad = ( target ) => { const io = new IntersectionObserver (( entries , observer ) => { entries . forEach (( entry ) => { if ( entry . isIntersecting ) { const img = entry . target ; const srcset = img . getAttribute ( \"data-lazy\" ); img . setAttribute ( \"srcset\" , srcset ); observer . disconnect (); } }); }); io . observe ( target ); }; targets . forEach ( lazyLoad );","title":"Image Lazy Loading"},{"location":"8.performance/#webp-support","text":"WebP is an efficient image coding format, it performs on average 30% better than JPEG or PNG for images size. The choice was clear, use only WebP. WebP as a 89% market share, but on some web browsers it's still new, like for example Firefox on Android, it supports WebP only since January 26. There is a way to show JPEG/PNG images to users who haven't yet updated their web browsers and WebP images to those who have updated their software, it will involve the Intersection Observer API, but this is a solution for another time.","title":"WebP Support"},{"location":"8.performance/#graphql","text":"","title":"GraphQL"},{"location":"8.performance/#caching","text":"https://github.com/besSejrani/PWA-Camera/blob/master/src/js/utils/lazyImages.ts \u21a9","title":"Caching"},{"location":"9.seo/","text":"SEO Performance Semantics Open Graph Protocols","title":"SEO"},{"location":"9.seo/#seo","text":"","title":"SEO"},{"location":"9.seo/#performance","text":"","title":"Performance"},{"location":"9.seo/#semantics","text":"","title":"Semantics"},{"location":"9.seo/#open-graph-protocols","text":"","title":"Open Graph Protocols"},{"location":"a.hosting/","text":"Hosting Vercel Client Development Service URI Port Client http://localhost 3000 Client Production Service URI Port Client https://blueberry-shop.vercell.app 80 Heroku Server Development Service URI Port User http://localhost:4000/graphql 4000 Server Production Service URI Port User http://localhost:4000/graphql 4000 MongoDB Atlas Github Pages Sources Source Author URI Prevent Your Free Heroku Dyno From Sleeping Hackernoon Link","title":"Hosting"},{"location":"a.hosting/#hosting","text":"","title":"Hosting"},{"location":"a.hosting/#vercel","text":"","title":"Vercel"},{"location":"a.hosting/#client-development","text":"Service URI Port Client http://localhost 3000","title":"Client Development"},{"location":"a.hosting/#client-production","text":"Service URI Port Client https://blueberry-shop.vercell.app 80","title":"Client Production"},{"location":"a.hosting/#heroku","text":"","title":"Heroku"},{"location":"a.hosting/#server-development","text":"Service URI Port User http://localhost:4000/graphql 4000","title":"Server Development"},{"location":"a.hosting/#server-production","text":"Service URI Port User http://localhost:4000/graphql 4000","title":"Server Production"},{"location":"a.hosting/#mongodb-atlas","text":"","title":"MongoDB Atlas"},{"location":"a.hosting/#github-pages","text":"","title":"Github Pages"},{"location":"a.hosting/#sources","text":"Source Author URI Prevent Your Free Heroku Dyno From Sleeping Hackernoon Link","title":"Sources"},{"location":"b.problems/","text":"Problems Time To Live MongoDB The forgot password functionnality relies on a specific TTL value to be executed. In MongoDB it is possible to specify a an expiration time, but it deletes the entier document and not just an individual field. To resolve this issue, Redis will be used instead. Redis feels just to be the right tool for the right job. Heroku offers a free tier, it's plenty enough. Typegoose @ Property ({ expires : \"30s\" , default : Date . now () }) changePassword : Date ;","title":"Problems"},{"location":"b.problems/#problems","text":"","title":"Problems"},{"location":"b.problems/#time-to-live-mongodb","text":"The forgot password functionnality relies on a specific TTL value to be executed. In MongoDB it is possible to specify a an expiration time, but it deletes the entier document and not just an individual field. To resolve this issue, Redis will be used instead. Redis feels just to be the right tool for the right job. Heroku offers a free tier, it's plenty enough. Typegoose @ Property ({ expires : \"30s\" , default : Date . now () }) changePassword : Date ;","title":"Time To Live MongoDB"},{"location":"c.roadmap/","text":"Road Map Feature Idea Add CI/CD pipeline. Add/Replace MongoDB with Neo4j and build a recommendation system. Add cross selling capabilities to the store. Enhance search experience with autocomplete feature, maybe implement Solr or Elasticsearch. Apple like product presentation. Add Progressive Web Application capabilities to the site. Add fallback to WebP images with the Intersection Observer API. Convert the MVC architecture into microservices with the help of Docker, Kubernetes and Istio.","title":"Road Map"},{"location":"c.roadmap/#road-map","text":"","title":"Road Map"},{"location":"c.roadmap/#feature-idea","text":"Add CI/CD pipeline. Add/Replace MongoDB with Neo4j and build a recommendation system. Add cross selling capabilities to the store. Enhance search experience with autocomplete feature, maybe implement Solr or Elasticsearch. Apple like product presentation. Add Progressive Web Application capabilities to the site. Add fallback to WebP images with the Intersection Observer API. Convert the MVC architecture into microservices with the help of Docker, Kubernetes and Istio.","title":"Feature Idea"}]}